# Контрактное программирование

**Контракты** - это правила валидации входных и выходных параметров функций.

Для работы с контрактами в Python используем библиотеку PyContracts.

Контракты нужны, для того чтобы:

- сделать динамически типизированный код стабильнее и защищеннее; 

- чтобы писать больше тестов для бизнес-логики и не заморачиваться с проверкой корректности структур данных.

**Контракты** дают уверенность в корректности типов аргументов и возвращаемых значений.

PyContracts поддерживает синтаксис Python 3 type hinting.

Контракты проверяются только в тестовом окружении и не замедляют продуктив.



### **Специфика контрактов**

Контракты могут быть реализованы тремя способами:

1. Использование ``@contract`` декоратор:

   ```python
   @contract(a='int,>0', b='list[N],N>0', returns='list[N]')
   def my_function(a, b):
       ...
   ```

2. Использование аннотаций (for Python 3):

   ```python
   @contract
   def my_function(a : 'int,>0', b : 'list[N],N>0') -> 'list[N]':
        # Requires b to be a nonempty list, and the return
        # value to have the same length.
        ...
   ```

3. Использование строк документации, вместе с `:type:` и `:rtype:` tags:

   ```python
   @contract
   def my_function(a, b):
       """ Function description.
           :type a: int,>0
           :type b: list[N],N>0
           :rtype: list[N]
       """
   ```


## **Проектирование по контракту и защитное программирование**

Одним из главных принципов проектирования по контракту является отсутствие проверок предусловий внутри тела программы. Это правило противоречит принципам защитного программирования, в котором **открытые методы класса предполагают, что данные небезопасны и отвечают за их проверку и исправление. Если данные были проверены открытыми методами класса, закрытые методы могут считать, что данные безопасны (McConnell)**. При этом внутри открытых методов рекомендуется применять обработчики ошибок (например, генерировать исключение или возвращать соответствующий код ошибки, в случае неверных входных данных), а в закрытых методах применять утверждения `assertions` (поскольку это характеризует программные ошибки).

Как было показано в предыдущем разделе, в проектировании по контракту никто не отказывается от проверки ненадежных данных. Ключевое различие между контрактным и защитным программированием заключается в месте прохождения границы между ненадежной и доверенной средами. В проектировании по контракту эта граница проходит в модулях ввода и обработки входных данных, а в защищенном программировании она проходит по открытому интерфейсу любого класса.

Кроме того, в защитном программировании существует негласное правило, согласно которому **лишняя проверка никогда не повредит**.

Основные принципы разработки (которые не имеют никакого отношения к контрактам) говорят о том, что лучше всего, чтобы класс или функция решала только одну задачу, но делала это хорошо. Одна дополнительная проверка внутри функции `Sqrt` в вашей домашней работе по информатике никакой погоды не сделает, но если говорить о реальных крупных проектах, то в них код обработки ошибок может занимать более половины всего кода.

Проектирование по контракту идет по пути *чем меньше и конкретнее задача, тем проще разработка, поддержка и сопровождение код*. *С этой глобальной точки зрения простота становится критическим фактором. Сложность – главный враг качества… Добавляя избыточные проверки, добавляете больше кода. Больше кода – больше сложности, отсюда и больше источников условий, приводящих к тому, что все пойдет не так, это приведет к дальнейшему разрастанию кода и так до бесконечности. Если пойти по этой дороге, то определенно можно сказать одно – мы никогда не достигнем надежности. Чем больше пишем, тем больше придется писать (Meyer)*.

Автор проектирования по контракту, **Бертран Мейер** считает, что обеспечение надежности отдельных модулей недостаточно для построения надежного ПО. *Для систем сколь либо существенных размеров недостаточно обеспечение качества отдельных элементов, - более важно гарантировать, что для каждого взаимодействия двух элементов задан явный список взаимных обязательств и преимуществ – контракт*.

## **Когда контракт нарушается**
Я говорил о том, что поставщик не должен проверять предусловие в своем коде, он может положиться на его выполнение и не рассматривать случаи его нарушения. Но что же произойдет во время выполнения при нарушении контракта и что семантически значит нарушение предусловия, постусловия или инварианта? Давайте попробуем найти ответы на все эти вопросы.
Нарушение контракта означает отклонение конкретной реализации от заданной спецификации, что говорит о некорректности реализации и является проявлением ошибок в программном коде.

Нарушение предусловия в период выполнения означает наличие ошибок на стороне клиента (поскольку за выполнение предусловия отвечает клиент; в этом случае «виноват заказчик» и ошибки находятся в его коде). При этом выполнение заданной функции не является целесообразным. Нарушение постусловия означает нарушение контракта со стороны поставщика, что в свою очередь означает наличие ошибок в реализации услуги (при этом предполагается, что вызов метода осуществляется при выполненном предусловии).

Как я говорил ранее, инвариант класса можно рассматривать как добавление еще одного утверждения в предусловия и постусловия всех экспортируемых методов класса, и поскольку его соблюдение ложится на поставщика услуги, то нарушение инварианта эквивалентно нарушению постусловия (т.е. это ошибка в коде поставщика).

Конкретные проявления нарушения контракта во время выполнения определяются, прежде всего, уровнем мониторинга периода выполнения (который может регулироваться при компиляции приложения). Так, техника проектирования по контракту изначально предусматривает возможность изменения степени мониторинга, в зависимости от уверенности в качестве полученного кода. В общем случае, при включенном мониторинге нарушение утверждения в период выполнения приводит к генерации исключения, но некоторые реализации позволяют выбирать поведение между исключениями и стандартным механизмом нарушения утверждений (которое приводит к прерыванию работы приложения).

## Пример функций

```python
from contracts import contract

# Сумма а и b
@contract
def ExampleSum(a, b):
    """
    :param a: int|float > 0 # тип может быть либо int либо float
    :param b: int|float > 0
    :return: int|float
    """
    return a + b

# Деление a на b
@contract
def ExampleDiv(a, b):
    """
    :param a: int|float != 0
    :param b: int|float != 0
    :return: int|float
    """
    if a != 0 & b != 0:
    	return a / b
    else: return 37007
```


