# **Инспекция кода**
**Инспекция кода** (англ. *code inspection*) или **рецензирование кода, обзор кода, ревизия кода** (англ. *code review*) — систематическая проверка исходного кода программы. 

>**Задача**: улучшение качества ПО путем обнаружения и исправления ошибок, допущенных при его разработке, а также совершенствование навыков разработчика.

В процессе инспекции кода могут быть найдены и устранены такие проблемы, как: 
- ошибки в форматировании строк; 
- состояние гонки;
- утечка памяти;
- переполнение буфера.

К очевидным плюсам этой практики можно отнести:
- улучшение качества кода;
- нахождение «глупых» ошибок (опечаток) в реализации;
- повышение степени совместного владения кодом;
- приведение кода к единому стилю написания;
- получение нового опыта, обмен знаниями и т.д.

## **Что можно инспектировать**

Для ревью подходит любой код. Однако, review **обязательно** должно проводиться для критических мест в приложении, таких как: 
1. механизмы аутентификации
2. механизмы авторизации
3. механизмы передачи и обработки ценной информации (денежных транзакций и пр.)

Также для review подходят и юнит-тесты, поскольку их код также подвержен ошибкам.
**Неправильный тест может стоить очень дорого.**

## **На что смотреть во время инспекции**
### Архитектура/Дизайн
- **Принцип «одной ответственности».** Идея в том, что у каждого класса должно быть только одно назначение, что применимо также и к методам. *Если возникает нужда в союзе «и» при описании того, что делает метод, то стоит разделить его на несколько более простых.*


- **Принцип «Открыт/Закрыт».** Если язык объектно-ориентированный, убедитесь открыты ли ваши объекты для расширения, но закрыты для модификации.


- **Дупликация кода.** При повторении одного и того же куска кода 3 или более раз, необходимо вынести его в отдельный метод.


- **Поиск багов.** Просматривайте код на наличие ошибок-на-единицу, нарушений условий циклов и т.д.


- **Эффективность.** Проверяйте, эффективна ли реализация какого-либо алгоритма.

### Стиль

- **Имена методов.** Давать имена различным вещам — одна из самых сложных задач в программировании. Если метод называется ```get_message_queue_name()```, но делает что-то кроме этого, например, убирает HTML из входных данных, тогда это имя не подходит ему.

- **Имена переменных.** Будьте как можно лаконичнее и выбирайте говорящие имена переменных, которые облегчат чтение кода в будущем.

- **Длина классов**. Классы должны быть меньше 300 строк, а в идеале — меньше 100. Скорее всего, если в вашем коде есть длинные классы, то их можно разбить на несколько, что облегчит понимание их предназначения.

- **Длина файла**. Для Python 1000 строк в одном файле — предел. Возможно, стоит разбить файл на несколько, улучшить читабельность кода.

- **Документация.** Сложные методы лучше задокументировать так, чтобы было понятно, за что отвечает каждый аргумент.

### Тестирование

- **Полнота тестов**. Необходимо продумывать тесты так, чтобы можно было в полной мере оценить возможности и недостатки кода. (Могут ли они заставить ваш код упасть? Легко ли они читаются? Насколько они хрупки?)

- **Тестирование на правильном уровне**. Нужно убедиться, тестируется ли тот уровень приложения, который нужно тестировать для проверки функциональности. Гарри Бернардт рекомендует такое соотношение — 95% юнит-тестов и 5% интеграционных тестов.

- **Количество объектов-имитаций.** Если в тесте более трех имитационных объектов, нужно его переписать.

- **Соответствование требованиям.** Если тест не соответствует каким-то критериям, то лучше провести тестирование заново.

## **Как проводить инспектирование кода**

- **Задавайте вопросы.** Задавайте вопросы, которые подтолкнут разработчиков к обсуждению. Например, как работает этот метод? Если изменится какое-то требование, то что нужно будет поменять в коде? Как сделать код более поддерживаемым?

- **Делайте комплименты и поощрения.** Одна из самых важных вещей в тестировании — награждение разработчиков за рост и приложение усилий. 

- **Обсуждайте детали наедине.** Большие архитектурные изменения лучше обсуждать всей командой, в то время как про мелкие детали лучше говорить наедине с разработчиком, который ответственен за них, дабы не вовлекать лишних людей.

- **Объясняйте причины.** Всегда лучше рассказать или спросить, почему предложенные изменения необходимы. Порой может возникнуть чувство, что они несущественны, до тех пор, пока вы не объясните повод.

- **Дело в коде.** Обсуждайте сам код, а не разработчиков, которые его писали. Это создаcт непринужденную атмосферу, тем более, программисты ни при чем — инспектирование призвано улучшить качество кода.

- **Указывайте на важность изменений.** Если вы считаете, что ваше предложение важно, то стоит сказать об этом, тогда на него обратят внимание и быстрее начнут двигаться в нужном направлении, что создаст видимость результата.

## **Статический анализатор кода**

В двух словах: ускорение и упрощение.

Статический анализ позволяет найти уйму различных проблем в коде: начиная от неправильного использования конструкций языка, заканчивая опечатками. Например, вместо
~~~
auto x = obj.x;
auto y = obj.y;
auto z = obj.z;
~~~
Вы написали следующий код:
~~~
auto x = obj.x;
auto y = obj.y;
auto z = obj.y;
~~~
Как видите, в последней строке появилась опечатка. Например, PVS-Studio выдаёт следующее предупреждение:
**V537 Consider reviewing the correctness of 'y' item's usage.**

Не всегда можно обратить внимания на подобные участки кода сразу и из-за этого можно засесть за отладку на добрый час, недоумевая, почему всё работает так странно.

Однако это явная ошибка. А если разработчик написал неоптимальный код из-за того, что позабыл какую-либо тонкость языка? Или же вовсе допустил в коде undefined behavior? К сожалению, подобные случаи совершенно обыденны и львиная часть времени тратится на то, чтобы отладить специфично работающий код, который содержит опечатки, типичные ошибки или **undefined behavior**.

Именно для этих ситуаций и появился статический анализ. Это помощник для разработчика, который укажет ему на различные проблемы в коде и объяснит в документации почему так писать не нужно, к чему это может привести и как это исправить.

# **Статические анализаторы кода, используемых для языка C#**

## PVS-Studio
#### https://www.viva64.com/ru/pvs-studio/

**PVS-Studio** — проприетарный статический анализатор кода для программ, написанных на С, C++, C++/CLI, C++/CX, C# и на Java

Приложение может интегрироваться с Microsoft Visual Studio, IntelliJ IDEA, Rider, SonarQube, Jenkins, TeamCity, IncrediBuild и так далее.

PVS-Studio выполняет статический анализ кода и генерирует отчёт, помогающий программисту находить и устранять ошибки. Приложение выполняет широкий спектр проверок кода, но наиболее силён в поисках опечаток и последствий неудачного Copy-Paste.

## ReSharper
#### https://www.jetbrains.com/ru-ru/resharper/

**ReSharper (R#)** — дополнение (плагин), разработанное компанией JetBrains для повышения продуктивности работы в Microsoft Visual Studio.

Проводит статический анализ кода (поиск ошибок в коде до компиляции) в масштабе всего решения, предусматривает дополнительные средства автозаполнения, навигации, поиска, подсветки синтаксиса, форматирования, оптимизации и генерации кода, предоставляет 40 автоматизированных рефакторингов, упрощает юнит-тестирование в средах MSTest и NUnit и др. Поддерживает языки программирования C#, C++, JavaScript, TypeScript и VB.NET, а также предоставляет средства для работы с ASP.NET, ASP.NET MVC, XML, XAML, HTML, CSS, сценариями сборки NAnt и MSBuild.


## FxCop

**FxCop** — бесплатный инструмент для статического анализа кода от Microsoft, проверяющий сборки .NET на соответствие рекомендациям по проектированию библиотек .NET Framework. В отличие от утилиты lint, FxCop анализирует скомпилированный объектный код, а не исходный код. FxCop использует разбор CIL и анализ графа вызовов для проверки сборок на наличие более чем 200 дефектов в следующих областях:

- Корректность
- Дизайн библиотек
- Интернационализация
- Соглашения именования
- Производительность
- Безопасность

FxCop представляет собой инструмент, помогающий разработчикам следовать корпоративным стандартам программирования. FxCop выполняет анализ кода для проверки соответствия стандартам программирования и соглашениям именования, и позволяет удостовериться, что соответствующие правила используются в написанной программе.

# **Сравнение PVS-Studio C# и статического анализатора, встроенного в Visual Studio, на базе кода проекта CruiseControl.NET**
>CruiseControl.NET — это сервер автоматической непрерывной интеграции, реализованный с использованием .NET Framework. Исходный код CruiseControl.NET доступен на GitHub. Проект уже некоторое время не развивается и не поддерживается, хотя, в недалёком прошлом пользовался определённой популярностью. Это не помешает применить его с целью сравнения анализаторов, скорее, даже наоборот, внесёт некий элемент стабильности в исследование. 

## **Исследование и результаты**
### **1. Visual Studio**

Проверка кода проекта при помощи встроенного в Visual Studio анализатора заняла всего пару минут. Сразу после этого результаты имеют следующий вид (никакие фильтры не включены):

![](https://hsto.org/getpro/habr/post_images/629/9fa/c08/6299fac082ad314ea7ce27855f6568ff.png)

Анализатор выдал 10773 предупреждения. Да, искать ошибки здесь будет не так-то просто. Для начала стоит исключить из данного списка предупреждения по проекту «UnitTests» при помощи фильтра:

![](https://hsto.org/getpro/habr/post_images/ca9/a9e/cf7/ca9a9ecf75696932f5dbc52c17c6b8db.png)

Почти половина предупреждений была получена для тестов, что неудивительно. Но более 5 тысяч оставшихся сообщений — тоже не мало. Также было выдано некоторое количество предупреждений компилятора. Видимо, не остается другого выбора, кроме как изучить описание каждой из полученных диагностик анализатора, а уже затем проводить изучение предупреждений в случае необходимости.

### **1. PVS-Studio**

Проверка кода проекта с помощью PVS-Studio заняла ровно минуту. Сразу после этого результаты имеют вид (никакие фильтры не включены):

![](https://hsto.org/getpro/habr/post_images/4e3/66d/b33/4e366db33c298ad0aae79b80f11a8faf.png)

Анализатор выдал 198 предупреждений. И них 45 было получено для проекта «UnitTests», а ещё 32 предупреждения имеют низкий приоритет (среди них сложно найти реальные ошибки). Итого — 121 сообщение для анализа, на который было потрачено 30 минут. В результате было выявлено 19 ошибок:

![](https://hsto.org/getpro/habr/post_images/4da/4f8/4ef/4da4f84ef9a12d0532aa2a5cf40cdb66.png)

## **Пример статического анализа**
В пример взята программа PVS-studio. Она пользуется огромной популярностью и может выявить огромное колличество ошибок и опечаток.

Пример:
~~~c
#include <cstdlib>

int *my_alloc() { return new int; }

void use(int *p) { *p = 1; }

void foo(bool x, bool y)
{
    int *a = nullptr;
    int *b = nullptr;
    
    a = my_alloc();
    a = my_alloc();

    use(a);
    use(b);

    std::free(a);
    std::free(b);
}
~~~
**Во-первых**, код содержит опечатку, из-за которой в переменную ```a``` дважды подряд записываются адреса двух выделенных буферов памяти. Это приводит к потере одного указателя, и анализатор предупреждает об утечке памяти. Ещё одно последствие опечатки – разыменование нулевого указателя внутри функции ```use```.

**Во-вторых**, память была выделена с помощью оператора ```new```, а освобождается с помощью вызова функции ```free```.

Анализатор выдаёт предупреждения, выявляющие все эти дефекты:
- **V522** Dereferencing of the null pointer 'p' might take place. The null pointer is passed into 'use' function. Inspect the first argument. Check lines: 7, 18.
- **V773** The 'a' pointer was assigned values twice without releasing the memory. A memory leak is possible.
- **V519** The 'a' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 14, 15.
- **V611** The memory was allocated using 'new' operator but was released using the 'free' function. Consider inspecting operation logics behind the 'a' variable.

**Источники:**

1. https://habr.com/ru/post/142564/#comments
2. https://ru.wikipedia.org/wiki/Просмотр_кода
3. https://tproger.ru/translations/code-review-best-practices/ 